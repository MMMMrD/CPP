# C++ -动态内存管理



## 为什么需要动态内存？

​	在程序运行的过程中，往往需要对内存进行动态的管理



## 动态内存的构成

​	C++的动态内存由一些没有名字、只有地址的内存块构成，这些内存块实在程序运行期间动态分配的。他们来自一个由标准C++库替你管理的 ==“内存池”==



## 申请动态内存

​	当需要申请一个动态内存的时候，需要用到 ***new*** 语句，代码如下

~~~c++
class Person
{
public:
    void test();
};

void Person::test()
{
    std::cout<<"我是一个人"<<std::endl;
}

int main()
{
    Person *person = new Person();  //new语句产生的是一个对应对象类型的指针
    
    delete person; //将申请的动态内存删除
    return 0;
}
~~~

**由以上的代码可以看到：**

1. C++中依然有指针的概念，在使用 ***new*** 语句后，会产生一个对应对象类型的指针
1. C++中，类中的访问修饰符要进行总写
1. C++中，用new语句申请的动态内存，在使用完成后 ==需要用 ***delete*** 语句将内存删除==



## ==动态数组==

​	数组与指针有着千丝万缕的关系，可以利用 ***new*** 语句创建一段动态数组，并用指针指向这段内存，例：

~~~C++
int *x = new int[10];
~~~

​	

​	当然，为了可以让用户决定该数组的大小，我们也可以进行如下的操作:

~~~c++
int count;
std::cin>>count;//等待用户将数值输入进变量count中

int *x =new int[count];
~~~



​	同样的，动态生成的数组一样也要在该段数据使用完之后，用 ***delete*** 语句进行删除：

~~~c++
int *x = new int[10];//创建动态数组

delete[] x;//将动态数组的内存删除
~~~



## ==避免内存泄漏==

​	内存泄漏可能会发生在两处，一个是在主函数之中，一个是在方法之中

### 主函数中的内存泄漏

​	正如下方代码：

~~~c++
int *x;
x = new int[1000];
x = new int[2000];

delete[] x;
x = NULL;
~~~

​	虽然在代码的最后用 ***delete*** 语句将x指向的内存删除，但在此之前x所指向的地址就被改写过，导致x之前指向的地址已经无法被访问，从而造成了内存的泄漏；

​	为了解决上述情况，建议在动态创建内存的时候，最好一个内存地址对应一个指针变量，防止有新创建的内存无法被访问的情况。

### 方法中的内存泄漏

​	如下方代码：

~~~c++
void test()
{
    int *ptr;
    ptr = new int[1000];
}
~~~

​	在该函数执行的过程中，有一个动态数组被创建，但在函数执行完全的时候，函数中创建的变量将会被删除，那么这个新创建的动态数组就会丢失指向他的指针，造成内存的泄漏。

​	为了解决上述情况，可以使用以下两种方法：

>1.在函数执行结束之前，将新创建的动态内存删除
>
>2.使用 ***return*** 语句，将新创建的动态内存返回，在函数外用一个指针接收

